//--------------------------------------//               PowerUI////        For documentation or //    if you have any issues, visit//        powerUI.kulestar.com////    Copyright © 2013 Kulestar Ltd//          www.kulestar.com//--------------------------------------using System;using UnityEngine;using PowerUI;namespace Css{		/// <summary>	/// Represents a box shadow for an element.	/// </summary>		public partial class BackgroundShadow:DisplayableProperty{				/// <summary>The colour the shadow should be with no colour overlay.</summary>		public Color BaseColour;		/// <summary>The width of the shadows blur.</summary>		public int BlurSize=4;						/// <summary>Creates a new box-shadow property for the given element.</summary>		/// <param name="data">The renderable object to give a shadow to.</param>		public BackgroundShadow(RenderableData data):base(data){}						public override void Paint(LayoutBox box,Renderman renderer){						MeshBlock block=GetFirstBlock(renderer);						if(block==null){				// This can happen if an animation is requesting that a now offscreen element gets painted only.				return;			}						block.PaintColour(BaseColour * renderer.ColorOverlay);					}				internal override void Layout(LayoutBox box,Renderman renderer){						// Get the top left inner corner (inside margin and border):			float width=box.PaddedWidth;			float height=box.PaddedHeight;			float top=box.Y+box.Border.Top;			float left=box.X+box.Border.Left;						// Is it clipped?			if(renderer.IsInvisible(left,top,width,height)){				// Totally not visible.				return;			}						// Ensure we have a batch (doesn't change graphics or font thus both nulls):			renderer.SetupBatch(this,null,null);						// Get the transform:			Transformation transform=renderer.Transform;						for(int y=0;y<3;y++){				for(int x=0;x<3;x++){										// Add it:					MeshBlock block=Add(renderer);										// Set the UV to that of the solid block colour pixel:					block.SetSolidColourUV();										// Set the colour - here we set it unevenly to trigger gradients.					// block.SetColour(BackingColour * renderer.ColorOverlay);										// BoxRegion clipZone=new BoxRegion(left,top,width,height);										// Set the verts too:					// block.SetClipped(renderer.ClippingBoundary,clipZone,renderer,box.ZIndex-0.006f);										block.Done(transform);									}			}					}			}	}